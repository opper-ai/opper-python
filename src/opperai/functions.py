"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from .sdkconfiguration import SDKConfiguration
from opperai import errors, models, utils
from opperai._hooks import HookContext
from opperai.revisions import Revisions
from opperai.types import OptionalNullable, UNSET
from opperai.utils import eventstreaming, get_security_from_env
from typing import Any, Dict, List, Mapping, Optional, Union


class Functions(BaseSDK):
    revisions: Revisions

    def __init__(self, sdk_config: SDKConfiguration) -> None:
        BaseSDK.__init__(self, sdk_config)
        self.sdk_configuration = sdk_config
        self._init_sdks()

    def _init_sdks(self):
        self.revisions = Revisions(self.sdk_configuration)

    def create(
        self,
        *,
        name: str,
        instructions: str,
        description: OptionalNullable[str] = UNSET,
        input_schema: OptionalNullable[Dict[str, Any]] = UNSET,
        output_schema: OptionalNullable[Dict[str, Any]] = UNSET,
        model: Optional[Union[models.TModel, models.TModelTypedDict]] = None,
        configuration: OptionalNullable[
            Union[
                models.FunctionCallConfiguration,
                models.FunctionCallConfigurationTypedDict,
            ]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateFunctionResponse:
        r"""Create Function

        Create a function

        :param name: The name of the function. Must be unique within the project and can only contain letters, numbers, underscores and hyphens.
        :param instructions: The instructions for the function, this is the prompt that will be sent to the model to complete the task. Recommended to be concise and to the point
        :param description: Optional description of the function. This is used to describe the function to a user.
        :param input_schema: Optional input schema for the function. Can preferably include field descriptions to allow the model to reason about the input variables. Schema is validated against the input data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
        :param output_schema: Optional output schema for the function. Can preferably include field descriptions to allow the model to reason about the output variables. Schema is validated against the output data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
        :param model:
        :param configuration: Optional configuration for the function.Configuration is a dictionary of key-value pairs that can be used to override the default configuration for the function.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        # region convert-pydantic-schemas
        if input_schema is not UNSET and hasattr(input_schema, 'model_json_schema'):
            input_schema = input_schema.model_json_schema()
        if output_schema is not UNSET and hasattr(output_schema, 'model_json_schema'):
            output_schema = output_schema.model_json_schema()
        # endregion convert-pydantic-schemas

        request = models.CreateFunctionRequest(
            name=name,
            description=description,
            instructions=instructions,
            input_schema=input_schema,
            output_schema=output_schema,
            model=utils.get_pydantic_model(model, Optional[models.TModel]),
            configuration=utils.get_pydantic_model(
                configuration, OptionalNullable[models.FunctionCallConfiguration]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/functions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateFunctionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="create_function_functions_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "409", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.CreateFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "409", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.ConflictErrorData
            )
            raise errors.ConflictError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_async(
        self,
        *,
        name: str,
        instructions: str,
        description: OptionalNullable[str] = UNSET,
        input_schema: OptionalNullable[Dict[str, Any]] = UNSET,
        output_schema: OptionalNullable[Dict[str, Any]] = UNSET,
        model: Optional[Union[models.TModel, models.TModelTypedDict]] = None,
        configuration: OptionalNullable[
            Union[
                models.FunctionCallConfiguration,
                models.FunctionCallConfigurationTypedDict,
            ]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateFunctionResponse:
        r"""Create Function

        Create a function

        :param name: The name of the function. Must be unique within the project and can only contain letters, numbers, underscores and hyphens.
        :param instructions: The instructions for the function, this is the prompt that will be sent to the model to complete the task. Recommended to be concise and to the point
        :param description: Optional description of the function. This is used to describe the function to a user.
        :param input_schema: Optional input schema for the function. Can preferably include field descriptions to allow the model to reason about the input variables. Schema is validated against the input data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
        :param output_schema: Optional output schema for the function. Can preferably include field descriptions to allow the model to reason about the output variables. Schema is validated against the output data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
        :param model:
        :param configuration: Optional configuration for the function.Configuration is a dictionary of key-value pairs that can be used to override the default configuration for the function.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        # region convert-pydantic-schemas
        if input_schema is not UNSET and hasattr(input_schema, 'model_json_schema'):
            input_schema = input_schema.model_json_schema()
        if output_schema is not UNSET and hasattr(output_schema, 'model_json_schema'):
            output_schema = output_schema.model_json_schema()
        # endregion convert-pydantic-schemas

        request = models.CreateFunctionRequest(
            name=name,
            description=description,
            instructions=instructions,
            input_schema=input_schema,
            output_schema=output_schema,
            model=utils.get_pydantic_model(model, Optional[models.TModel]),
            configuration=utils.get_pydantic_model(
                configuration, OptionalNullable[models.FunctionCallConfiguration]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/functions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateFunctionRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="create_function_functions_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "409", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.CreateFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "409", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.ConflictErrorData
            )
            raise errors.ConflictError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def list(
        self,
        *,
        name: OptionalNullable[str] = UNSET,
        sort: OptionalNullable[str] = UNSET,
        offset: OptionalNullable[int] = UNSET,
        limit: OptionalNullable[int] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedResponseListFunctionsResponseItem:
        r"""List Functions

        List existing functions with the most recent revision in the current project

        :param name: Filter functions by name
        :param sort: Sort the functions by name or created_at, use '-' to sort in descending order
        :param offset: The offset of the page of functions to return when paginating
        :param limit: The number of functions to return per page when paginating
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListFunctionsFunctionsGetRequest(
            name=name,
            sort=sort,
            offset=offset,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/functions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_functions_functions_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.PaginatedResponseListFunctionsResponseItem
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_async(
        self,
        *,
        name: OptionalNullable[str] = UNSET,
        sort: OptionalNullable[str] = UNSET,
        offset: OptionalNullable[int] = UNSET,
        limit: OptionalNullable[int] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedResponseListFunctionsResponseItem:
        r"""List Functions

        List existing functions with the most recent revision in the current project

        :param name: Filter functions by name
        :param sort: Sort the functions by name or created_at, use '-' to sort in descending order
        :param offset: The offset of the page of functions to return when paginating
        :param limit: The number of functions to return per page when paginating
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListFunctionsFunctionsGetRequest(
            name=name,
            sort=sort,
            offset=offset,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/functions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_functions_functions_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.PaginatedResponseListFunctionsResponseItem
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get(
        self,
        *,
        function_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFunctionResponse:
        r"""Get Function

        Get the latest revision of a function by ID

        :param function_id: The id of the function to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetFunctionFunctionsFunctionIDGetRequest(
            function_id=function_id,
        )

        req = self._build_request(
            method="GET",
            path="/functions/{function_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_function_functions__function_id__get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.GetFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_async(
        self,
        *,
        function_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFunctionResponse:
        r"""Get Function

        Get the latest revision of a function by ID

        :param function_id: The id of the function to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetFunctionFunctionsFunctionIDGetRequest(
            function_id=function_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/functions/{function_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_function_functions__function_id__get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.GetFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update(
        self,
        *,
        function_id: str,
        name: OptionalNullable[str] = UNSET,
        description: OptionalNullable[str] = UNSET,
        instructions: OptionalNullable[str] = UNSET,
        input_schema: OptionalNullable[Dict[str, Any]] = UNSET,
        output_schema: OptionalNullable[Dict[str, Any]] = UNSET,
        model: OptionalNullable[Union[models.TModel, models.TModelTypedDict]] = UNSET,
        configuration: OptionalNullable[Dict[str, Any]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateFunctionResponse:
        r"""Update Function

        Update a function, this will create a new revision of the function

        :param function_id: Unique identifier of the function given as a UUID
        :param name: The name of the function. Must be unique within the project and can only contain letters, numbers, underscores and hyphens.
        :param description: Optional description of the function. This is used to describe the function to a user.
        :param instructions: The instructions for the function, this is the prompt that will be sent to the model to complete the task. Recommended to be concise and to the point
        :param input_schema: Optional input schema for the function. Can preferably include field descriptions to allow the model to reason about the input variables. Schema is validated against the input data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
        :param output_schema: Optional output schema for the function. Can preferably include field descriptions to allow the model to reason about the output variables. Schema is validated against the output data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
        :param model: Optionally provide a model to use for completing the task. If not provided, a default model will be used. Currently the default model is `azure/gpt-4o-eu`
        :param configuration: Optional configuration for the function.Configuration is a dictionary of key-value pairs that can be used to override the default configuration for the function.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        # region convert-pydantic-schemas
        if input_schema is not UNSET and hasattr(input_schema, 'model_json_schema'):
            input_schema = input_schema.model_json_schema()
        if output_schema is not UNSET and hasattr(output_schema, 'model_json_schema'):
            output_schema = output_schema.model_json_schema()
        # endregion convert-pydantic-schemas

        request = models.UpdateFunctionFunctionsFunctionIDPatchRequest(
            function_id=function_id,
            update_function_request=models.UpdateFunctionRequest(
                name=name,
                description=description,
                instructions=instructions,
                input_schema=input_schema,
                output_schema=output_schema,
                model=utils.get_pydantic_model(model, OptionalNullable[models.TModel]),
                configuration=configuration,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/functions/{function_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_function_request,
                False,
                False,
                "json",
                models.UpdateFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_function_functions__function_id__patch",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.UpdateFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_async(
        self,
        *,
        function_id: str,
        name: OptionalNullable[str] = UNSET,
        description: OptionalNullable[str] = UNSET,
        instructions: OptionalNullable[str] = UNSET,
        input_schema: OptionalNullable[Dict[str, Any]] = UNSET,
        output_schema: OptionalNullable[Dict[str, Any]] = UNSET,
        model: OptionalNullable[Union[models.TModel, models.TModelTypedDict]] = UNSET,
        configuration: OptionalNullable[Dict[str, Any]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateFunctionResponse:
        r"""Update Function

        Update a function, this will create a new revision of the function

        :param function_id: Unique identifier of the function given as a UUID
        :param name: The name of the function. Must be unique within the project and can only contain letters, numbers, underscores and hyphens.
        :param description: Optional description of the function. This is used to describe the function to a user.
        :param instructions: The instructions for the function, this is the prompt that will be sent to the model to complete the task. Recommended to be concise and to the point
        :param input_schema: Optional input schema for the function. Can preferably include field descriptions to allow the model to reason about the input variables. Schema is validated against the input data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
        :param output_schema: Optional output schema for the function. Can preferably include field descriptions to allow the model to reason about the output variables. Schema is validated against the output data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
        :param model: Optionally provide a model to use for completing the task. If not provided, a default model will be used. Currently the default model is `azure/gpt-4o-eu`
        :param configuration: Optional configuration for the function.Configuration is a dictionary of key-value pairs that can be used to override the default configuration for the function.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        # region convert-pydantic-schemas
        if input_schema is not UNSET and hasattr(input_schema, 'model_json_schema'):
            input_schema = input_schema.model_json_schema()
        if output_schema is not UNSET and hasattr(output_schema, 'model_json_schema'):
            output_schema = output_schema.model_json_schema()
        # endregion convert-pydantic-schemas

        request = models.UpdateFunctionFunctionsFunctionIDPatchRequest(
            function_id=function_id,
            update_function_request=models.UpdateFunctionRequest(
                name=name,
                description=description,
                instructions=instructions,
                input_schema=input_schema,
                output_schema=output_schema,
                model=utils.get_pydantic_model(model, OptionalNullable[models.TModel]),
                configuration=configuration,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/functions/{function_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_function_request,
                False,
                False,
                "json",
                models.UpdateFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_function_functions__function_id__patch",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.UpdateFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def delete(
        self,
        *,
        function_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Function

        Delete a function by ID

        :param function_id: Unique identifier of the function given as a UUID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteFunctionFunctionsFunctionIDDeleteRequest(
            function_id=function_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/functions/{function_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_function_functions__function_id__delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def delete_async(
        self,
        *,
        function_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Function

        Delete a function by ID

        :param function_id: Unique identifier of the function given as a UUID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteFunctionFunctionsFunctionIDDeleteRequest(
            function_id=function_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/functions/{function_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_function_functions__function_id__delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_by_name(
        self,
        *,
        name: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFunctionResponse:
        r"""Get Function By Name

        Get the latest revision of a function by name

        :param name: The name of the function to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetFunctionByNameFunctionsByNameNameGetRequest(
            name=name,
        )

        req = self._build_request(
            method="GET",
            path="/functions/by-name/{name}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_function_by_name_functions_by_name__name__get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.GetFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_by_name_async(
        self,
        *,
        name: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFunctionResponse:
        r"""Get Function By Name

        Get the latest revision of a function by name

        :param name: The name of the function to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetFunctionByNameFunctionsByNameNameGetRequest(
            name=name,
        )

        req = self._build_request_async(
            method="GET",
            path="/functions/by-name/{name}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_function_by_name_functions_by_name__name__get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.GetFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_by_revision(
        self,
        *,
        function_id: str,
        revision_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFunctionResponse:
        r"""Get Function By Revision

        Get a function by ID with a specific revision

        :param function_id: The id of the function to retrieve
        :param revision_id: The id of the revision to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetFunctionByRevisionFunctionsFunctionIDRevisionsRevisionIDGetRequest(
            function_id=function_id,
            revision_id=revision_id,
        )

        req = self._build_request(
            method="GET",
            path="/functions/{function_id}/revisions/{revision_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_function_by_revision_functions__function_id__revisions__revision_id__get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.GetFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_by_revision_async(
        self,
        *,
        function_id: str,
        revision_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFunctionResponse:
        r"""Get Function By Revision

        Get a function by ID with a specific revision

        :param function_id: The id of the function to retrieve
        :param revision_id: The id of the revision to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetFunctionByRevisionFunctionsFunctionIDRevisionsRevisionIDGetRequest(
            function_id=function_id,
            revision_id=revision_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/functions/{function_id}/revisions/{revision_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_function_by_revision_functions__function_id__revisions__revision_id__get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.GetFunctionResponse)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def call(
        self,
        *,
        function_id: str,
        input: OptionalNullable[Any] = UNSET,
        parent_span_id: OptionalNullable[str] = UNSET,
        examples: OptionalNullable[
            Union[List[models.ExampleIn], List[models.ExampleInTypedDict]]
        ] = UNSET,
        tags: OptionalNullable[Dict[str, str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppAPIPublicV2FunctionsCallFunctionResponse:
        r"""Call Function

        Call a function

        :param function_id: The id of the function to call
        :param input: Input to the function
        :param parent_span_id:
        :param examples:
        :param tags: Tags to add to the call event
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CallFunctionFunctionsFunctionIDCallPostRequest(
            function_id=function_id,
            app_api_public_v2_functions_call_function_request=models.AppAPIPublicV2FunctionsCallFunctionRequest(
                input=input,
                parent_span_id=parent_span_id,
                examples=utils.get_pydantic_model(
                    examples, OptionalNullable[List[models.ExampleIn]]
                ),
                tags=tags,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/functions/{function_id}/call",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.app_api_public_v2_functions_call_function_request,
                False,
                False,
                "json",
                models.AppAPIPublicV2FunctionsCallFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="call_function_functions__function_id__call_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AppAPIPublicV2FunctionsCallFunctionResponse
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def call_async(
        self,
        *,
        function_id: str,
        input: OptionalNullable[Any] = UNSET,
        parent_span_id: OptionalNullable[str] = UNSET,
        examples: OptionalNullable[
            Union[List[models.ExampleIn], List[models.ExampleInTypedDict]]
        ] = UNSET,
        tags: OptionalNullable[Dict[str, str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppAPIPublicV2FunctionsCallFunctionResponse:
        r"""Call Function

        Call a function

        :param function_id: The id of the function to call
        :param input: Input to the function
        :param parent_span_id:
        :param examples:
        :param tags: Tags to add to the call event
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CallFunctionFunctionsFunctionIDCallPostRequest(
            function_id=function_id,
            app_api_public_v2_functions_call_function_request=models.AppAPIPublicV2FunctionsCallFunctionRequest(
                input=input,
                parent_span_id=parent_span_id,
                examples=utils.get_pydantic_model(
                    examples, OptionalNullable[List[models.ExampleIn]]
                ),
                tags=tags,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/functions/{function_id}/call",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.app_api_public_v2_functions_call_function_request,
                False,
                False,
                "json",
                models.AppAPIPublicV2FunctionsCallFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="call_function_functions__function_id__call_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AppAPIPublicV2FunctionsCallFunctionResponse
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def stream(
        self,
        *,
        function_id: str,
        input: OptionalNullable[Any] = UNSET,
        parent_span_id: OptionalNullable[str] = UNSET,
        examples: OptionalNullable[
            Union[List[models.ExampleIn], List[models.ExampleInTypedDict]]
        ] = UNSET,
        tags: OptionalNullable[Dict[str, str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.StreamFunctionFunctionsFunctionIDCallStreamPostResponse:
        r"""Stream Function

        Stream a function call execution in real-time using Server-Sent Events (SSE).

        This endpoint returns a continuous stream of Server-Sent Event objects as the function executes,
        allowing for real-time streaming of responses. The response follows the Server-Sent Events
        specification with proper event structure for SDK compatibility.

        Each Server-Sent Event contains:
        - `id`: Optional event identifier
        - `event`: Optional event type
        - `data`: JSON payload with streaming chunk information
        - `retry`: Optional retry interval

        The data payload includes:
        - `delta`: Incremental text content (if any)
        - `span_id`: Unique identifier for the execution span (when available)

        :param function_id: The id of the function to call
        :param input: Input to the function
        :param parent_span_id:
        :param examples:
        :param tags: Tags to add to the call event
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamFunctionFunctionsFunctionIDCallStreamPostRequest(
            function_id=function_id,
            app_api_public_v2_functions_call_function_request=models.AppAPIPublicV2FunctionsCallFunctionRequest(
                input=input,
                parent_span_id=parent_span_id,
                examples=utils.get_pydantic_model(
                    examples, OptionalNullable[List[models.ExampleIn]]
                ),
                tags=tags,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/functions/{function_id}/call/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.app_api_public_v2_functions_call_function_request,
                False,
                False,
                "json",
                models.AppAPIPublicV2FunctionsCallFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="stream_function_functions__function_id__call_stream_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "text/event-stream"):
            return models.StreamFunctionFunctionsFunctionIDCallStreamPostResponse(
                result=eventstreaming.EventStream(
                    http_res,
                    lambda raw: utils.unmarshal_json(
                        raw,
                        models.StreamFunctionFunctionsFunctionIDCallStreamPostResponseBody,
                    ),
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "400", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def stream_async(
        self,
        *,
        function_id: str,
        input: OptionalNullable[Any] = UNSET,
        parent_span_id: OptionalNullable[str] = UNSET,
        examples: OptionalNullable[
            Union[List[models.ExampleIn], List[models.ExampleInTypedDict]]
        ] = UNSET,
        tags: OptionalNullable[Dict[str, str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.StreamFunctionFunctionsFunctionIDCallStreamPostResponse:
        r"""Stream Function

        Stream a function call execution in real-time using Server-Sent Events (SSE).

        This endpoint returns a continuous stream of Server-Sent Event objects as the function executes,
        allowing for real-time streaming of responses. The response follows the Server-Sent Events
        specification with proper event structure for SDK compatibility.

        Each Server-Sent Event contains:
        - `id`: Optional event identifier
        - `event`: Optional event type
        - `data`: JSON payload with streaming chunk information
        - `retry`: Optional retry interval

        The data payload includes:
        - `delta`: Incremental text content (if any)
        - `span_id`: Unique identifier for the execution span (when available)

        :param function_id: The id of the function to call
        :param input: Input to the function
        :param parent_span_id:
        :param examples:
        :param tags: Tags to add to the call event
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamFunctionFunctionsFunctionIDCallStreamPostRequest(
            function_id=function_id,
            app_api_public_v2_functions_call_function_request=models.AppAPIPublicV2FunctionsCallFunctionRequest(
                input=input,
                parent_span_id=parent_span_id,
                examples=utils.get_pydantic_model(
                    examples, OptionalNullable[List[models.ExampleIn]]
                ),
                tags=tags,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/functions/{function_id}/call/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.app_api_public_v2_functions_call_function_request,
                False,
                False,
                "json",
                models.AppAPIPublicV2FunctionsCallFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="stream_function_functions__function_id__call_stream_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "text/event-stream"):
            return models.StreamFunctionFunctionsFunctionIDCallStreamPostResponse(
                result=eventstreaming.EventStreamAsync(
                    http_res,
                    lambda raw: utils.unmarshal_json(
                        raw,
                        models.StreamFunctionFunctionsFunctionIDCallStreamPostResponseBody,
                    ),
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "400", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def call_revision(
        self,
        *,
        function_id: str,
        revision_id: str,
        input: OptionalNullable[Any] = UNSET,
        parent_span_id: OptionalNullable[str] = UNSET,
        examples: OptionalNullable[
            Union[List[models.ExampleIn], List[models.ExampleInTypedDict]]
        ] = UNSET,
        tags: OptionalNullable[Dict[str, str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppAPIPublicV2FunctionsCallFunctionResponse:
        r"""Call Function Revision

        Call a function

        :param function_id: The id of the function to call
        :param revision_id: The id of the revision to call
        :param input: Input to the function
        :param parent_span_id:
        :param examples:
        :param tags: Tags to add to the call event
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CallFunctionRevisionFunctionsFunctionIDCallRevisionIDPostRequest(
            function_id=function_id,
            revision_id=revision_id,
            app_api_public_v2_functions_call_function_request=models.AppAPIPublicV2FunctionsCallFunctionRequest(
                input=input,
                parent_span_id=parent_span_id,
                examples=utils.get_pydantic_model(
                    examples, OptionalNullable[List[models.ExampleIn]]
                ),
                tags=tags,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/functions/{function_id}/call/{revision_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.app_api_public_v2_functions_call_function_request,
                False,
                False,
                "json",
                models.AppAPIPublicV2FunctionsCallFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="call_function_revision_functions__function_id__call__revision_id__post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AppAPIPublicV2FunctionsCallFunctionResponse
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def call_revision_async(
        self,
        *,
        function_id: str,
        revision_id: str,
        input: OptionalNullable[Any] = UNSET,
        parent_span_id: OptionalNullable[str] = UNSET,
        examples: OptionalNullable[
            Union[List[models.ExampleIn], List[models.ExampleInTypedDict]]
        ] = UNSET,
        tags: OptionalNullable[Dict[str, str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppAPIPublicV2FunctionsCallFunctionResponse:
        r"""Call Function Revision

        Call a function

        :param function_id: The id of the function to call
        :param revision_id: The id of the revision to call
        :param input: Input to the function
        :param parent_span_id:
        :param examples:
        :param tags: Tags to add to the call event
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CallFunctionRevisionFunctionsFunctionIDCallRevisionIDPostRequest(
            function_id=function_id,
            revision_id=revision_id,
            app_api_public_v2_functions_call_function_request=models.AppAPIPublicV2FunctionsCallFunctionRequest(
                input=input,
                parent_span_id=parent_span_id,
                examples=utils.get_pydantic_model(
                    examples, OptionalNullable[List[models.ExampleIn]]
                ),
                tags=tags,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/functions/{function_id}/call/{revision_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.app_api_public_v2_functions_call_function_request,
                False,
                False,
                "json",
                models.AppAPIPublicV2FunctionsCallFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="call_function_revision_functions__function_id__call__revision_id__post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AppAPIPublicV2FunctionsCallFunctionResponse
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def stream_revision(
        self,
        *,
        function_id: str,
        revision_id: str,
        input: OptionalNullable[Any] = UNSET,
        parent_span_id: OptionalNullable[str] = UNSET,
        examples: OptionalNullable[
            Union[List[models.ExampleIn], List[models.ExampleInTypedDict]]
        ] = UNSET,
        tags: OptionalNullable[Dict[str, str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> (
        models.StreamFunctionRevisionFunctionsFunctionIDCallStreamRevisionIDPostResponse
    ):
        r"""Stream Function Revision

        Stream a function revision call execution in real-time using Server-Sent Events (SSE).

        This endpoint returns a continuous stream of Server-Sent Event objects as the function executes,
        allowing for real-time streaming of responses. The response follows the Server-Sent Events
        specification with proper event structure for SDK compatibility.

        Each Server-Sent Event contains:
        - `id`: Optional event identifier
        - `event`: Optional event type
        - `data`: JSON payload with streaming chunk information
        - `retry`: Optional retry interval

        The data payload includes:
        - `delta`: Incremental text content (if any)
        - `span_id`: Unique identifier for the execution span (when available)

        :param function_id: The id of the function to call
        :param revision_id: The id of the revision to call
        :param input: Input to the function
        :param parent_span_id:
        :param examples:
        :param tags: Tags to add to the call event
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamFunctionRevisionFunctionsFunctionIDCallStreamRevisionIDPostRequest(
            function_id=function_id,
            revision_id=revision_id,
            app_api_public_v2_functions_call_function_request=models.AppAPIPublicV2FunctionsCallFunctionRequest(
                input=input,
                parent_span_id=parent_span_id,
                examples=utils.get_pydantic_model(
                    examples, OptionalNullable[List[models.ExampleIn]]
                ),
                tags=tags,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/functions/{function_id}/call/stream/{revision_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.app_api_public_v2_functions_call_function_request,
                False,
                False,
                "json",
                models.AppAPIPublicV2FunctionsCallFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="stream_function_revision_functions__function_id__call_stream__revision_id__post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "text/event-stream"):
            return models.StreamFunctionRevisionFunctionsFunctionIDCallStreamRevisionIDPostResponse(
                result=eventstreaming.EventStream(
                    http_res,
                    lambda raw: utils.unmarshal_json(
                        raw,
                        models.StreamFunctionRevisionFunctionsFunctionIDCallStreamRevisionIDPostResponseBody,
                    ),
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "400", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def stream_revision_async(
        self,
        *,
        function_id: str,
        revision_id: str,
        input: OptionalNullable[Any] = UNSET,
        parent_span_id: OptionalNullable[str] = UNSET,
        examples: OptionalNullable[
            Union[List[models.ExampleIn], List[models.ExampleInTypedDict]]
        ] = UNSET,
        tags: OptionalNullable[Dict[str, str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> (
        models.StreamFunctionRevisionFunctionsFunctionIDCallStreamRevisionIDPostResponse
    ):
        r"""Stream Function Revision

        Stream a function revision call execution in real-time using Server-Sent Events (SSE).

        This endpoint returns a continuous stream of Server-Sent Event objects as the function executes,
        allowing for real-time streaming of responses. The response follows the Server-Sent Events
        specification with proper event structure for SDK compatibility.

        Each Server-Sent Event contains:
        - `id`: Optional event identifier
        - `event`: Optional event type
        - `data`: JSON payload with streaming chunk information
        - `retry`: Optional retry interval

        The data payload includes:
        - `delta`: Incremental text content (if any)
        - `span_id`: Unique identifier for the execution span (when available)

        :param function_id: The id of the function to call
        :param revision_id: The id of the revision to call
        :param input: Input to the function
        :param parent_span_id:
        :param examples:
        :param tags: Tags to add to the call event
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamFunctionRevisionFunctionsFunctionIDCallStreamRevisionIDPostRequest(
            function_id=function_id,
            revision_id=revision_id,
            app_api_public_v2_functions_call_function_request=models.AppAPIPublicV2FunctionsCallFunctionRequest(
                input=input,
                parent_span_id=parent_span_id,
                examples=utils.get_pydantic_model(
                    examples, OptionalNullable[List[models.ExampleIn]]
                ),
                tags=tags,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/functions/{function_id}/call/stream/{revision_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.app_api_public_v2_functions_call_function_request,
                False,
                False,
                "json",
                models.AppAPIPublicV2FunctionsCallFunctionRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="stream_function_revision_functions__function_id__call_stream__revision_id__post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "text/event-stream"):
            return models.StreamFunctionRevisionFunctionsFunctionIDCallStreamRevisionIDPostResponse(
                result=eventstreaming.EventStreamAsync(
                    http_res,
                    lambda raw: utils.unmarshal_json(
                        raw,
                        models.StreamFunctionRevisionFunctionsFunctionIDCallStreamRevisionIDPostResponseBody,
                    ),
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "400", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.BadRequestErrorData
            )
            raise errors.BadRequestError(data=response_data)
        if utils.match_response(http_res, "401", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.UnauthorizedErrorData
            )
            raise errors.UnauthorizedError(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.NotFoundErrorData
            )
            raise errors.NotFoundError(data=response_data)
        if utils.match_response(http_res, "422", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(
                http_res_text, errors.RequestValidationErrorData
            )
            raise errors.RequestValidationError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
