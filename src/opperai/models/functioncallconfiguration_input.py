"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from opperai.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import Any, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class FunctionCallConfigurationInputTypedDict(TypedDict):
    invocation_few_shot_count: NotRequired[int]
    r"""The number of few-shot examples to use for the call. The examples are selected using nearest neighbor search of the function's dataset for items that are similar to the input."""
    beta_evaluation: NotRequired[Nullable[Any]]
    r"""[DEPRECATED] This field is ignored. Evaluation is controlled by observer_enabled."""
    invocation_structured_generation_max_attempts: NotRequired[int]
    r"""The maximum number of attempts to make when generating a response matching the output schema if provided."""
    invocation_cache_ttl: NotRequired[int]
    r"""The time to live for the cache in seconds. If 0, the cache is disabled."""
    beta_invocation_input_validation_enabled: NotRequired[bool]
    r"""Whether to enable input validation against the input schema. This is a beta feature and is disabled by default."""
    beta_invocation_xml_mode_enabled: NotRequired[bool]
    r"""Experimental: enable XML structured output. The model receives an XML schema and its response is converted back to JSON. We have observed better adherence to multi-paragraph text fields (especially with Anthropic models) when this is enabled."""


class FunctionCallConfigurationInput(BaseModel):
    invocation_few_shot_count: Annotated[
        Optional[int], pydantic.Field(alias="invocation.few_shot.count")
    ] = 0
    r"""The number of few-shot examples to use for the call. The examples are selected using nearest neighbor search of the function's dataset for items that are similar to the input."""

    beta_evaluation: Annotated[
        OptionalNullable[Any], pydantic.Field(alias="beta.evaluation")
    ] = UNSET
    r"""[DEPRECATED] This field is ignored. Evaluation is controlled by observer_enabled."""

    invocation_structured_generation_max_attempts: Annotated[
        Optional[int],
        pydantic.Field(alias="invocation.structured_generation.max_attempts"),
    ] = 5
    r"""The maximum number of attempts to make when generating a response matching the output schema if provided."""

    invocation_cache_ttl: Annotated[
        Optional[int], pydantic.Field(alias="invocation.cache.ttl")
    ] = 0
    r"""The time to live for the cache in seconds. If 0, the cache is disabled."""

    beta_invocation_input_validation_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="beta.invocation.input_validation.enabled")
    ] = False
    r"""Whether to enable input validation against the input schema. This is a beta feature and is disabled by default."""

    beta_invocation_xml_mode_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="beta.invocation.xml_mode.enabled")
    ] = False
    r"""Experimental: enable XML structured output. The model receives an XML schema and its response is converted back to JSON. We have observed better adherence to multi-paragraph text fields (especially with Anthropic models) when this is enabled."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "invocation.few_shot.count",
            "beta.evaluation",
            "invocation.structured_generation.max_attempts",
            "invocation.cache.ttl",
            "beta.invocation.input_validation.enabled",
            "beta.invocation.xml_mode.enabled",
        ]
        nullable_fields = ["beta.evaluation"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
